from DataAlias import DataAlias
from DataEntry import DataEntry


class DataManager():
    numStepsStorage = 1  # default size of a data object

    # TODO: check the comments

    '''
    The data manager stores all properties of the data that we mantain for
    the different experiments. It is organized hierarchically for storing
    data on different time scales. For example, we can store data on the
    level of the "episodes", e.g., "parameters", or on the level of the
    single steps of an episode, e.g., "states" and "actions".

    @section datamanager_entry Data Entry
    For each level of the hierarchy, we have an individual data manager,
    which need to be connected by setting a "subDataManager". For
    each data entry, we have to set the dimensionality. We also can set
    the range of the data entry and specify whether some dimensions of the
    data entry are periodic or not.

    @section datamanager_alias Data Alias
    In addition to data entries, we can define data alias
    (see addDataAlias). A data alias can be seen as a pointer that points
    to other data entries. It can point to a subIndex set of a single
    data entry or of mulitple data entries. For example, we could have
    the data entries "weights", "goal" and "goalVel" (describing the
    parameters of a DMP). In order to learn all parameters at once, we
    can define a data alias "parameters" that points to the
    concantenation of "weights", "goal" and "goalVel".

    @section datamanager_functionality Additional functionality
    The data manager also has the basic functionality you need to obtain
    the properties of the data or to compute the level of the hierarchy
    of a specific data entry. When registering a new data entry, always
    be aware that we have to register it at the correct data manager for
    the desired hierarchy. The data managers can be obtained by the
    functions getDataManagerForName or getDataManagerForDepth.

    @section datamanager_lazy Lazy Feature Generation
    Finally, the data managers also allow for lazy evaluations of features.
    In this case, we can add FeatureGenerators.FeatureGenerator for specify
    data entries.
    Everytime the data entry is retrieved from the data structure, the
    FeatureGenerator is asked whether the value in the data entry is still
    valid. To do so, each data entry that is generated by a feature
    generator gets an additional data entry with the suffix "Tag". The
    tag is used to check whether the feature values are still active. It
    is recommended to use the two test files "+tests/testDataManager.m"
    and "+tests/testDataManagerAlias.m" to get a better feeling for the
    data management.
    '''

    def __init__(self, name):
        '''Constructor'''
        self.name = name
        self.__subDataManager = None
        self.dataEntries = dict()
        self.dataAliases = dict()

    @property
    def subDataManager(self):
        return self.__subDataManager

    @subDataManager.setter
    def subDataManager(self, subDataManager):
        '''Sets the subDataManager for this DataManager'''
        self.__subDataManager = subDataManager

    @subDataManager.getter
    def subDataManager(self):
        '''Getter for the subDataManager'''
        return self.__subDataManager

    def addDataEntry(self, name, size, minRange=-1, maxRange=1):
        '''
        Function for adding a new data entry. If the same data entry already
        exists, then the properties are overwritten. minRange and maxRange are
        optional arguments (standard values are a vector of -1 and +1). Both
        arguments need to be row vectors with the same size as the specified
        dimensionality. The function automatically adds a data alias pointing
        to the same data entry.
        '''
        self.dataEntries[name] = DataEntry(name, size, minRange, maxRange)
        self.addDataAlias(name, {name: Ellipsis})

    def addDataAlias(self, aliasName, entryList):
        '''
        Adds a data alias with the name "aliasName". entryList should be a
        dict of data entries and slices to these data entries. If the whole
        data entry should be used, use "..." instead of a slice. This means
        the alias should point to all dimensions of the data entry.
        If a data alias already exists, it will be overwritten.
        '''
        for key, value in entryList.items():

            if key not in self.dataEntries:
                raise ValueError("The data entry " + key + " does not exist")

            print(key, value)

        self.dataAliases[aliasName] = DataAlias(aliasName, entryList)

    def getDataObject(self, numElements):
        '''
        Creates a new data object with numElements data points, whereas
        numElements is a vector defining the number of elements for each layer
        of the hierarchy. If no numElements are defined, the size of the data
        object is the standard size (numStepsStorage).
        '''
        # TODO: implement this
