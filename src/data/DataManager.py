import numpy as np
from Data import Data
from DataEntry import DataEntry


class DataManager():
    numStepsStorage = 1  # default size of a data object

    # TODO: check the comments

    '''
    The data manager stores all properties of the data that we mantain for
    the different experiments. It is organized hierarchically for storing
    data on different time scales. For example, we can store data on the
    level of the "episodes", e.g., "parameters", or on the level of the
    single steps of an episode, e.g., "states" and "actions".

    @section datamanager_entry Data Entry
    For each level of the hierarchy, we have an individual data manager,
    which need to be connected by setting a "subDataManager". For
    each data entry, we have to set the dimensionality. We also can set
    the range of the data entry and specify whether some dimensions of the
    data entry are periodic or not.

    @section datamanager_alias Data Alias
    In addition to data entries, we can define data alias
    (see addDataAlias). A data alias can be seen as a pointer that points
    to other data entries. It can point to a subIndex set of a single
    data entry or of mulitple data entries. For example, we could have
    the data entries "weights", "goal" and "goalVel" (describing the
    parameters of a DMP). In order to learn all parameters at once, we
    can define a data alias "parameters" that points to the
    concantenation of "weights", "goal" and "goalVel".

    @section datamanager_functionality Additional functionality
    The data manager also has the basic functionality you need to obtain
    the properties of the data or to compute the level of the hierarchy
    of a specific data entry. When registering a new data entry, always
    be aware that we have to register it at the correct data manager for
    the desired hierarchy. The data managers can be obtained by the
    functions getDataManagerForName or getDataManagerForDepth.

    @section datamanager_lazy Lazy Feature Generation
    Finally, the data managers also allow for lazy evaluations of features.
    In this case, we can add FeatureGenerators.FeatureGenerator for specify
    data entries.
    Everytime the data entry is retrieved from the data structure, the
    FeatureGenerator is asked whether the value in the data entry is still
    valid. To do so, each data entry that is generated by a feature
    generator gets an additional data entry with the suffix "Tag". The
    tag is used to check whether the feature values are still active. It
    is recommended to use the two test files "+tests/testDataManager.m"
    and "+tests/testDataManagerAlias.m" to get a better feeling for the
    data management.
    '''

    def __init__(self, name):
        '''Constructor'''
        self.name = name
        self.__subDataManager = None
        self.dataEntries = dict()
        self.dataAliases = dict()

    @property
    def subDataManager(self):
        return self.__subDataManager

    @subDataManager.setter
    def subDataManager(self, subDataManager):
        '''Sets the subDataManager for this DataManager'''
        self.__subDataManager = subDataManager

    @subDataManager.getter
    def subDataManager(self):
        '''Getter for the subDataManager'''
        return self.__subDataManager

    def addDataEntry(self, name, size, minRange=-1, maxRange=1):
        '''
        Function for adding a new data entry. If the same data entry already
        exists, then the properties are overwritten. minRange and maxRange are
        optional arguments (standard values are a vector of -1 and +1). Both
        arguments need to be row vectors with the same size as the specified
        dimensionality. The function automatically adds a data alias pointing
        to the same data entry.
        '''

        self.dataEntries[name] = DataEntry(name, size, minRange, maxRange)
        self.addDataAlias(name, {name: Ellipsis})
        
    def _checkForAliasCycle(self, aliasName, entryList):
        '''
        Detects circular dependencies between aliases.
        It is assumed that the entryList is valid, i.e. all entry names 
        correspond either to valid entries or aliases.
        '''
        for entryName in entryList:
            if entryName not in self.dataEntries:
                if aliasName == entryName:
                    return True
                return self._checkForAliasCycle(aliasName, self.dataAliases[entryName])
        return False
                    

    def addDataAlias(self, aliasName, entryList):
        '''
        Adds a data alias with the name "aliasName". entryList should be a
        dict of data entries and slices to these data entries. If the whole
        data entry should be used, use "..." instead of a slice. This means
        the alias should point to all dimensions of the data entry.
        '''

        # Ensure that all referenced names are in the entry list
        if all(entryName in self.dataAliases or entryName in self.dataEntries for entryName in
               entryList.keys()):
            
            if self._checkForAliasCycle(aliasName, entryList):
                raise ValueError("Alias cycle detected!")
            
            # Test if the alias has already been defined
            if aliasName in self.dataAliases:
                # Replace slices
                for entryName, sl in entryList.items():
                    self.dataAliases[aliasName][entryName] = sl
            else:
                self.dataAliases[aliasName] = entryList

            # TODO: move to Data.py
            # Computes the total number of dimensions for the alias
            #numDim = 0
            #for entryName, sl in self.dataAliases[aliasName].items():
            #    numDim += len(self.dataEntries[entryName][sl])
            # TODO Store alias dimensions somewhere
        else:
            if self.subDataManager() is not None:
                self.subDataManager().addDataAlias(aliasName, entryList)
            else:
                raise ValueError("One or more of the alias entry names do " +
                                 "not exist")

    def getAliasNames(self):
        '''
        Returns the names of all aliases (including subdatamanagers)
        '''
        names = self.dataAliases.keys()
        if (self.subDataManager() is not None):
            names += self.subDataManager().getAliasNames()
        return names;

    def getElementNames(self):
        '''
        Returns the names of all data entries (including subdatamanagers)
        '''
        names = self.dataEntries.keys()
        if (self.subDataManager() is not None):
            names += self.subDataManager().getElementNames()
        return names

    def getAliasNamesLocal(self):
        '''
        Returns the names of all aliases (only of this data manager)
        '''
        return self.dataAliases.keys()

    def getElementNamesLocal(self):
        '''
        Returns the names of all data entries (only of this data manager)
        '''
        return self.dataEntries.keys()

    def getDataObject(self, numElements):
        '''
        Creates a new data object with numElements data points, whereas
        numElements is a vector defining the number of elements for each layer
        of the hierarchy. If no numElements are defined, the size of the data
        object is the standard size (numStepsStorage).
        '''
        return Data(self, self.getDataStructure(numElements))

    def getDataStructure(self, numElements):
        '''
        Creates the data structure (containing real data) for the data object
        '''
        if isinstance(numElements, list):
            numElementsCurrentLayer = numElements[0]
            numElements = numElements[1:]
        else:
            numElementsCurrentLayer = numElements

        dataStructure = dict()
        for dataEntryName, dataEntry in self.dataEntries.items():
            dataStructure[dataEntryName] = np.zeros((numElementsCurrentLayer,
                                                    dataEntry.size),
                                                    dtype=np.float64)

        if (self.subDataManager is not None):
            subStructure = self.subDataManager.getDataStructure(numElements)
            dataStructure[self.subDataManager.name] = subStructure

        return dataStructure
